;;; feature/projects/+auto-mode.el -*- lexical-binding: t; -*-
;;
;; Copyright (c) 2018 Boris Buliga
;;
;; Author: Boris Buliga <boris@d12frosted.io>
;; Maintainer: Boris Buliga <boris@d12frosted.io>
;;
;; Created: 23 Nov 2018
;;
;; URL: https://github.com/d12frosted/environment/emacs
;;
;; License: GPLv3
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;; This gem was implemented by hlissner
;;
;;; Code:

(defvar-local +project-auto-modes nil
  "A symbol or a list of project modes you want to enable.

Available for .dir-locals.el.")

(defvar +project-auto-hook nil
  "Hook run when a project is enabled. 

The name of the project's mode and its state are passed in.")

(defun +project|init-auto-mode ()
  "Auto-enable the project(s) listed in `+project-auto-modes'."
  (when +project-auto-modes
    (if (symbolp +project-auto-modes)
        (funcall +project-auto-modes)
      (cl-loop for mode in +project-auto-modes
               unless (symbol-value mode)
               do (funcall mode)))))

(cl-defmacro def-project-mode! (name
				&key
                                modes
                                files
                                when
                                match
                                add-hooks
                                on-load
                                on-enter
                                on-exit)
  "Define a project minor-mode named NAME (a symbol) and declare
where and how it is activated. Project modes allow you to
configure 'sub-modes' for major-modes that are specific to a
specific folder, certain project structure, framework or
arbitrary context you define. These project modes can have their
own settings, keymaps, hooks, snippets, etc.

This creates NAME-hook and NAME-map as well.

A project can be enabled through .dir-locals.el too, by setting
`+project-auto-modes'.

PLIST may contain any of these properties, which are all checked
to see if NAME should be activated. If they are *all* true, NAME
is activated.

  :modes MODES -- if buffers are derived from MODES (one or a
    list of symbols).

  :files FILES -- if project contains FILES; takes a string or a
    form comprised of nested (and ...) and/or (or ...)
    forms. Each path is relative to the project root, however, if
    prefixed with a '.' or '..', it is relative to the current
    buffer.

  :match REGEXP -- if file name matches REGEXP

  :when PREDICATE -- if PREDICATE returns true (can be a form or
    the symbol of a function)

  :add-hooks HOOKS -- HOOKS is a list of hooks to add this mode's
    hook.

  :on-load FORM -- FORM to run the first time this project mode
    is enabled.

  :on-enter FORM -- FORM is run each time the mode is activated.

  :on-exit FORM -- FORM is run each time the mode is disabled.

Relevant: `+project-auto-hook'."
  (declare (indent 1))
  (let ((init-var (intern (format "%s-init" name))))
    `(progn
       ,(if on-load `(defvar ,init-var nil))
       (define-minor-mode ,name
         "A project minor mode generated by `def-project-mode!'."
         :init-value nil
         :lighter ""
         :keymap (make-sparse-keymap)
         (if (not ,name)
             ,on-exit
           (run-hook-with-args '+project-auto-hook ',name ,name)
           ,(when on-load
              `(unless ,init-var
                 ,on-load
                 (setq ,init-var t)))
           ,on-enter))
       ,@(cl-loop for hook in add-hooks
                  collect `(add-hook ',(intern (format "%s-hook" name))
                                     #',hook))
       ,(when (or modes match files when)
          `(associate! ,name
             :modes ,modes
             :match ,match
             :files ,files
             :when ,when)))))
